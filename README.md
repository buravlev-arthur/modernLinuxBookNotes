# modernLinuxBookNotes

Important notes from "Learning modern Linux" (Hausenblas M. - 2022).

### Глава 1. Введение

`cat /proc/version` - версия Linux
`cat /proc/cpuinfo | grep "model name"` - информация о ядрах ЦП
`cat /proc/$$/status | head -n6` - первые шесть строк статуса текущего процесса (переменная $$ - текущий процесс)

### Глава 2. Ядро Linux

#### Процессор

`lscpu` - информация о процессоре
`uname -m` - архитектура процессора
`cat /proc/cpuinfo` - вся информация о всех CPU

##### Управление процессами в Linux

- Сессии (SID)
- Группы процессов (PGID)
- Процесс (адресное пространство, потоки, сокеты и т.п. (PID))
- Потоки (TID) / Мультипотоки (TGID) - в Linux представляют из себя процессы, которые раздают процессам ресурсы
- Задачи (структура task_struct определена в sched.h - базовая реализация Потоков и Процессов)

`ls /proc/self` - данные текущего процесса
`ps -j` - данные процессов
`ls /proc/<PID>/task/<TID>` - увидеть данные и ресурсы задачи процесса

#### Память RAM

Виртуальная память -> Процесс [таблица страниц памяти процесса] <- Физическая память (RAM)
TLB кэширует физические адреса страниц памяти процесса для ускорения работы процессора.
Стандартный размер страницы памяти - 4 KB. В сорвеменных Linux используются более крупные страницы памяти.

`grep MemTotal /proc/meminfo` - объяем физической памяти
`grep VmallocTotal /proc/meminfo` - объём виртуальной памяти
`grep Hugepagesize /proc/meminfo` - размер страницы памяти

#### Сеть

Linux-стек:

- Сокеты (абстракции соединений)
- TCP/UDP
- IP

`ip link` - сетевые интерфейсы
`ip route` - сетевые маршруты

#### Файловая система

Множество видов: ext4, ntfs, btrfs.
VFS - виртуальные файловые сестемы используется для одновременной работы со множеством типов и экземляров файловых систем.

#### Устройства

Драйверы устройств (физических и псевдо-устройств) хранятся в ядре статически или в виде модулей.

`ls /sys/devices` - список устройств

#### Системные вызовы

Несколько сотен. Вызываются напрямую, либо через "C standart library" (реализации: glibc, musl).
Системные вызовы - это программные прерывания, вызывающие исключения, которые передают управление обработчику исключения.
В syscall.h хранится таблица системных вызовов (переменная sys_call_table), хранящая последовательность системных вызовов и их обработчиков.
system_call() - функция мультиплексор, сохранающая контекст ап.обеспечения в стэк, делающая проверки и вызывающая в конце обработчик исключения из sys_call_table.

`strace ls` - список системных вызовов, вызываемых командой ls
`strace -c curl -s https://google.ru > /dev/null` - вывод затрат времени на системные вызовы (/dev/null - направить вывод вникуда)

Список системных вызовов: https://filippo.io/linux-syscall-table/

#### Расширения ядра

`uname -srm` - имя, релиз ядра и архитектура машины
`find /lib/modules/$(uname -r) -name "*.ko*" -type f` - поиск доступных модулей для текущего ядра
`lsmod` или `cat /proc/modules` - список загруженных модулей
`modprobe --show-depends video` - показать зависимости модуля video

##### eBPF (Berkeley Packet Filter)

Начиная с версии Linux-ядра 3.15 расширать его функциональность можно с помощью системного вызова bpf. eBPF реализован как виртуальная машина внутри ядра с набором RISC-инструкций.

### Глава 3. Оболочки и сценарии

`echo $TERM` - название используемого терминала
`infocmp` - конфигурация используемого терминала
`sh` - запуск оболочки (сегодня по-умолчанию bash (Bourne Again Shell), наследница оригинальной Bourne Shell)
`echo $0` - имя используемой оболочки (а вообще имя текущего процесса)

#### Потоки

Оболочка определяет для каждого процесса три файловых дескриптора (FDs):

- stdin (FD 0)
- stdout (FD 1)
- stderr (FD 2)

`cat file.txt 1> output.txt 2> err.txt` - вывести поток stdout из файла file.txt в файл output output.txt а stderr - в err.txt
`cat file.txt &> output.txt` - вывести оба потока stdout и stderr в output.txt
`cat file.txt > /dev/null` - убрать поток stdout
`cat > output.txt` - записывать ввод в файл (Ctrl + D для выхода и сохранения)
`tr < result.txt [A-Z] [a-z]` - команда tr читает поток stdin из файла result.txt и заменяет все заглавные символы на строчные
`echo "Error" >&2` - вывод строки Error в поток stderr

Специальные символы:
`&` - выполняет команду в фоновом режиме
`/` - переводит запись команды на следующую строку
`|` - передаёт stdout (команды слева) в stdin (команды справа)

Команда убирает статус об ошибке, передают stdout curl'а в stdin wc и записана с переносом строки (/):

```bash
curl https://example.com 2> /dev/null | \
wc -l
```

#### Переменные

- Переменные окружения (`env`)
- Переменные оболочки (`set`)

`set MY_VAR=42` - создаём переменную оболочки
`set | grep 'MY_VAR'` - выводим переменную со значением
`export MY_GLOBAL_VAR=42` - создаём переменную окружения
`env | grep 'MY_GLOBAL_VAR'` - выводим переменную окружения
`unset $MY_VAR` - удаление переменной
`bash` - создаём новую сессию - дочерний процесс процесса текущей сессии
`exit` - выход из процесса сессии
`echo $?` - статус выхода (exit status). 0 - успешно, 1-255 - ошибка
`echo $PIPESTATUS` - тот же exit status, но для применения в конвеерах

#### Предустановленные команды оболочки

Расположены:
`/usr/bin` - пользовательские команды
`/usr/sbin` - административные команды

`which cat` или `type cat` - узнать, где расположен исполняемый код команды cat

#### Shell jobs

`watch -n 5 "ls" &` - watch выводит результат ls каждые 5 секунд, а & переводит работу в фоновый режим
`jobs -l` - список текущих работ
`fg` - перевести работу из фонового режима на экран

[Ctrl + C] - прекращение работы
[Ctrl + Z] - перевод работы в фоновый режим

`nohup ./job.sh` - работа не прикратит выполнение после закрытия терминала, а stdout направлен в ~/nohup.out
`disown -h 1000` - блокировка сигнала SIGNUP без удаление задачи и таблицы оболочки (-h), где 1000 - Job ID

#### Современные аналоги популярных команд

`exa` - просмотр каталога (Install: apt install exa)
`rg -t txt text` - найти и вывести файлы с расширением txt с текстом "text" (Install: $sudo apt-get install ripgrep)
`bat text.txt` - чтение файла с прокрутой (Install: sudo apt install bat; mkdir -p ~/.local/bin; ln -s /usr/bin/batcat ~/.local/bin/bat)
`jq '.[] | select(.favoriteFruit=="strawberry") | .friends[0].name' someData.json` - поиск в JSON имен первых друзей людей, кто любит клубнику (Install: sudo apt-get install jq)

#### Рутинные задачи

`alias d="exa -T -L 1"` - создание алиаса d для команды exa
`unalias d` - удаление алиаса

`echo "Second line" >> /tmp/file` - добавить строчку в конец файла
`sed 's/line/LINE/' /tmp/file` - замена всех подстрок line на LINE
`cat << 'EOF' > /tmp/file` - Записать введенный текст в file с помощью Here Document (https://tldp.org/LDP/abs/html/here-docs.html)
`diff -y file1 file2` - сравнение строк файлов в две колонки (-y)

##### Многостраничные файлы

Просмотр многостраничных файлов возможен с помощью пэйджеров: `less`, `bat`; или с помощью вывода куска файла: `head`, `tail`.
`head -5 file` - вывести первые пять строк файла
`tail -f file` - просмотр конца файла с обновлением при увеличении строк в файле (-f)

##### Дата и время

`date -d @1000000000 '+%d.%m.%Y %H:%M:%S'` - вывод даты и времени с timestamp 1000000000

##### Fish Shell

`set -x MY_VAR VALUE` - определение глобальной переменной
`set -e MY_VAR` - удалить глобальную переменную
`env MY_VAR=10 npm run dev` - установка переменной окружения для команды
`abbr --add l ls -la` - добавление синонима l для команды ls с параметрами -la
`config_fish` - открыть в браузере настройки оболочки
`functions` - просмотр всех доступных функций
`function func_name` - добавление/редактирование функции, пример:

```bash
function f
    git pull origin main
end
```

`funced func_name` - просмотр тела функции

##### Мультиплексор терминала

- "screen". Оригинальный, устаревший.
- "tmux". Состоит из трех элементов: сессии -> окна -> панели.

`tmux new -s test` - создание новой сессии test
`tmux ls` - просмотр всех сессий
`tmux attach -t test` - запуск сессии test в терминале

Команды tmux:
**trigger/prefix**: Ctrl + b

**trigger + $** - переименовать сессию
**trigger + s** - просмотреть все сессии
**trigger + d** - завершение текущей сессии

**trigger + c** - создание нового окна
**trigger + ,** - переименование окна
**trigger + [N | P]** - перейти к следующей/предыдущей странице
**trigger + [0-9]** - перейти в окно с указанным номером
**trigger + w** - просмотр всех окон в сессии
**trigger + &** - закрытие текущего окна

**trigger + "** - разделить окно горизонтально
**trigger + %** - разделить окно вертикально
**trigger + [up | down | left | right]** - перемещение между панелями
**trigger + z** - переключиться на текущую панель/на все панели
**trigger + x** - закрыть панель

##### Автоматизация (скрипты)

- Массивы
  `arr=('First', 'Second', 'Third')` - массив из трех элементов
  `echo ${arr[1]}` - вывод первого элемента массива
  `echo ${arr[@]}` - вывод всех элементов массива
  `echo ${#arr[@]}` - вывести количество элементов массива

- Цикл FOR

```bash
for afile in ~/* ; do
    echo $afile
done
```

```bash
for i in {1..10}; do
    echo $i
done
```

```bash
while true; do
    echo "Hello"
done
```

- Функции

```bash
sayhi() {
    echo "Hi $1 hope you are well!"
}

sayhi "John"
```

Требования к скрипту:

- .sh-расширение файла (хотя, не обязательно)
- в первой строке: #! (shebang, указывающий на интерпритатор). Например: #!/usr/bin/env bash
- файл должен быть исполняемый: `chmod +x` (могут исполнять _все_) или `chomd 750` (могут исполнять _пользователь_ и его _группа_)

**Шаблон скрипта**:

```bash
#!/usr/bin/env bash
# завершать, если найдена ошибка
set -o errexit
# выдавать ошибку, если переменные не определены
set -o nounset
# если часть конвейера с ошибкой, прерывать весь конвейер
set -o pipefail

firstargument="${1:-somedefaultvalue}"

echo "$firstargument"
```

**Хорошие практики**:

1. Завершать скрипт шумно и быстро (errexit, pipefail);
2. Чувствительная информация (пароль) должна передаваться в скрипт через пользователский ввод или через API;
   Команда `ps` выводит параметры программы и т.п;
3. Устанавливать значения по-умолчанию для параметров запуска и ввода (read), где это возможно. И валидировать полученные от пользователя данные;
4. Проверять наличие всех пакетов и при необходимости устанавливать их через скрипт (wget);
5. Обрабатывать ошибки и сообщать пользователю, что произшло и что делать;
6. Комментарировать (`# doc here`) и не писать строки длинее 80 символов;
7. Версионировать скрипты через Git;
8. Проводить линтинг и тестирование скриптов.

**Тестирование, линтинг и форматирование**:

- Линтинг:
  `sudo apt install -y shellcheck` - установка _shellcheck_
  `shellcheck script.sh` - линтинг script.sh скрипта

- Форматирование:
  `sudo apt install -y shfmt` - установка форматера _shfmt_
  `shfmt -l -w script.sh` - форматтинг скрипта script.sh

- Тестирование:
  `sudo apt install bats` - установка тестовой среды bats

Тестовые утверждения в tests.bats:

```
@test "invoking param string" {
        run ./firstScript.sh testString
        [ "$output" = "testString" ]
}

@test "invoking exit status" {
        run ./firstScript.sh testString
        [ "$status" -eq 0 ]
}
```

`bats tests.bats` - запуск тестов

- Шпаргалка по bash: https://devhints.io/bash
- Фреймворки: bashing, rr, rerun

### Глава 4. Контроль доступа

**Пользователь**: владеет ресурсом и запускает процесс
**Процесс**: использует ресурс

**Ресурс** - исполняемый файл, загруженный ядром в память и запущенный.

Два типа контроля доступа:

- Дискреционный доступ (DAC). Ограничение доступа основано на идентификаторе пользователя, который может давать права на свои ресурсы другим пользователям.
- Мандатный доступ. Представляет иерархию видов доступа, где пользователь имеет доступ только к ресурсам своего уровня или ниже. Только администратор
  может контролировать уровни доступа. Пользователь не может настраивать права доступа к ресурсам, которыми владеет. Реализации: SELinux, AppArmor.

Два типа пользователей:

- **Системные пользователи**. Чаще всего программы (_deamons_), которые могут быть частью ОС (_sshd_) или часть пользовательского ПО (_mysql_);
- **Обычные пользователи**. Например, живой человек, использующий Linux через shell.

_User ID (UID)_ 32-битный числовое значение, обрабатываемое Linux. Пользователь принадлежит к одной или нескольким группам, которые идентифицируются с помощью
_Group ID (GID)_. Пользователь с UID 0 - это root-пользователь.

Разные дистрибутивы по-своему управляют порядком UID. В дистрибутивах основанных на _systemd_ порядок следующий:

- 0 - root-пользователь;
- 1-999 - системные пользователи;
- 65534 - nobody-пользователь (используется например, для сопоставления удалённых пользователей с существующими);
- 1000 - 4 294 967 294 (кроме 65534) - обычные пользователи

`id -u` - вывод UID текующего пользователя

#### Локальное управление пользователями

`/etc/passwd` - база пользователей
`/etc/group` - база групп
`/etc/shadow` - пароли пользователей
`/etc/gshadow` - пароли групп

**Поля пользователя**:

`user:x:1000:2100:john adams:/user:/bin/bash` - запись в `/etc/passwd`, где справа-налево:

- `/bin/bash` - shell-оболочка для входа в систему (`/sbin/nologin` - если это системный пользователь);
- `/user` - домашняя директория пользователя;
- `john adams` - GECOS-поле; чаще всего полное имя пользователя;
- `2100` - основная группа (GID) пользователя;
- `1000` - идентификатор пользователя (UID);
- `x` - пароль зашифрован и хранится в `/etc/shadow`;
- `user` - имя пользователя в системе (не более 32 символов).

Добавить пользователя:

```bash
sudo adduser username
```

Команда создаёт запись в `/etc/passwd`, создаёт группу для пользователя в `/etc/group`, создаёт домашнюю директорию: `/home/username` и копирует в неё базовые конфигурации из
`/etc/skel`. Все настроки команды находятся в: `/etc/adduser.conf`.

Добавить системного пользователя (без домашней директории и shell'а для входа):

```bash
sudo adduser --system system_user_name
```

**Поля группы**:

`groupname:x:1000:user1,user2,user3` - запись в `etc/group`, где справа-налево:

- `user1,user2,user3` - пользователи, входящие в группу;
- `1000` - идентификатор группы (GID);
- `x` - пароль зашифрован и хранится в `/etc/gshadow`;
- `groupname` - имя группы; часто совпадает с именем обычного или системного (deamon'а) пользователя.

#### Централизованное управление пользователями

Подходы к централизованному управлению пользователями:

- **Основанный на директориях** - _LDAP (Lightweight Directory Access Protocol)_ - протокол управления доступом к директориям, распространяемым через IP-протокол. Опенсорс-сервер: [Keycloak](https://www.keycloak.org/);
- **Через сеть** - пользователи могут быть подключены через протокол _Keberos_;
- **Системы управления конфигурацией** - системы _Ansible_, _Chef_, _Puppet_ используются для последовательного создания пользователей на разных машинах.

Выбор подхода часто заранее продиктован определенным окружением.

#### Права доступа к файлам

Три типа пространств прав доступа:

- Пользователь (владелец файла);
- Группа (Один или более членов);
- Другие.

У каждого пространства три типа доступа:

- Чтение (`r`). Позволяет просматривать файл и имена файлов внутри директории;
- Запись (`w`). Позволяет редактировать файл и создавать/переименовывать/удалять файлы в директории;
- Исполнение (`x`). Позволяет исполнять файл (если также есть право на чтение) и даёт доступ к информации о файлах в директории (можно пользоваться командами `cd` и `ls`).

Также есть ещё несколько типов доступа:

- `s` - для исполняемых файлов. Позволяет пользователю, исполняющему файл наследовать права владельца/группы файла;
- `t` - для директорий. Запрещает удалять файлы внутри директорий не root-пользователю, если только он не является владельцем директории.

Строка из вывода команды `ls`:

`-rwxr-x--- 1 user group  593 Sep  1 15:56 gh-user-info.sh`, где слева-направо:

- `gh-user-info.sh` - имя файла;
- `Sep 1 15:56` - временная метка последнего обновления;
- `593` - размер файла в байтах;
- `group` - группа, которой пренадлежит файл;
- `user` - владелец файла;
- `1` - количество жёстких ссылок;
- `-rwxr-x---` - тип и права файла, где справа-налево:
  - `-` - тип файла со значениями:
    - `-` - обычный файл;
    - `d` - директория;
    - `l` - символическая ссылка;
    - `s` - сокет;
    - `b` - блочный файл;
    - `c` - символьный файл;
    - `?` - неизвестный тип файла.
  - `rwx` - права владельца файла;
  - `r-x` - права группы владельца;
  - `---` - права остальных пользователей.

Права для типа пространств (владелец, группа, другие) можно представить в виде числа, если перевести запись вида `rwx` в двоичный вид. Например для `r-x` это 5, а для `rwx` - 7.
Права `664` (чтение и запись для владельца и его группы и только чтение для остальных) присваивается в системе по умолчанию всем новым файлам.

`umask` - маска прав на новые файлы/директори по умолчанию. В ответе `0002` первая цифра опускается. Для файлов: `666 - 002 = 664`, для директорий: `777 - 002 = 775`.
`umask -S` - посмотреть права по-умолчанию в формате `u=rwx, g=rwx, o=rwx`.
`umask 224` - установить новую маску с правами для файлов: `442`, для директорий: `553`.

Изменение прав на файл:

`chmod +x file.txt` - добавить для всех право на исполнение
`chmod 644 file.txt` - установить права `rw-r--r--` для файла

Изменение владельца и группы:

`sudo chown username file.txt` - смена владельца фала на username
`sudo chgrp groupname file.txt` - смена группы на groupname

#### Права доступа к процессам

К процессу имеют доступ:

- **Real UID**. Пользователь, запустивший этот процесс (владелец). Получить UID можно с помощью системного вызова: `getuid(2)` или с помощью команды:

`stat -c "%u %g" /proc/$$/` - информация о владельце и группе-владельце текущего процесса;

- **Effective UID**. Используется для определения прав процесса на доступ к общим ресурсам. Получить можно с помощью: `geteuid(2)`;
- **Saved set-user-ID**. Используется для получения suid (root). Для получения необходимых прав процесс может переключать его _Effective UID_ между _Real UID_ и _Saved set-user-ID_. Например, для получения доступа к порту процессу должны быть предоставлены root-права. Может быть получен с помощью: `getresuid(2)`;
- **Filesystem UID**. Специфичен для Linux. Используется для предоставления доступа процессу к файлам от имени пользователя, который тем временем изолирован от действий над этим процессом. С версии ядря 2.0 может не использоваться, но поддержка сохранена путём синхронизации _Filesystem UID_ с _Effective UID_. Получить: `getfsuid(2)`.

_POSIX threads_ требует данные для входа, доступные всем потокам. Но ядро Linux поддерживает отдельные данные для входа для пользователей и групп в каждом потоке.

Ядро так же использует UID's процесса для других целей (помимо доступа к файлам): установка прав доступа для отправки сигналов (`kill -9`), обработки прав доступа для планирования и установки приоритетов, проверки ограничений ресурсов и т.д.


##### Capabitilites

Ядро Linux различает только два состояния:

- **Привелигированный процесс**: запущен от имени суперпользователя (_Effective UID_: 0), игнорирующий все проверки на права доступа ядра;
- **Непривелигированный процесс**: (_Effective UID_ отличен от 0), для которого ядро выполняет все проверки прав доступа.

C появлением системного вызова `capabilities(7)` привелигированный процесс (root) разбит на несколько независимых единиц, каждая из которых связана с соответствующим уровнем потоков.
Теперь можно исполняемым файлам (бинарным или shell-скриптам) постепенно увеличивать уровень _Capabilities_, чтобы они могли выполнить поставленную задачу.

`capsh --print` - просмотр всех capabilities
`grep Cap /proc/$$/status` - capabilities текущего процесса

Можно управлять capabilities с помощью команд `getcap` и `setcap`. 

##### Seccomp-профили

Secure computing mode (seccomp) позволяет с помощью системного вызова `seccomp(2)` ограничить системные вызовы, доступные процессу. _Docker_ и _Kubernets_ используют _Seccomp_ для формирования песочниц (изолированного окружения).


##### Access control list

_ACL_ позволяет наделять правами пользователей и группы, которых нет в списке групп пользователя.

`grep -i posix_acl=y /boot/config*` - проверка поддержки _ACL_ системой (если строчки `posix_acl=y` есть - _ACL_ поддерживается)

**Хорошие практики**:

1. **Меньше прав доступа**. Файлам стоит давать только те права доступа, которые необходимы для работы с ними. В `chmod` лучше использовать цифровые коды, нежели общие символы вроде: `+x`, которые дают доступ всем типам пользователей. Не входить в систему под root-пользователем, а использовать `sudo` по возможности. При написании приложений нужно использовать _SELinux_ с политикой, дающей приложению доступ только к выбранным файлам, директориям и другим видам ресурсов системы;
2. **Избегать setuid**. Вместо этого использовать `capabilities`;
3. **Аудирование**. Рекомендуется вести журнал действий, который нельзя подделеать, чтобы можно было контролировать кто когда и что делал в системе.

### Глава 5. Файловая система

Главная абстрация в Linux - файл. Почти всё в Linux - файл. Файлом помимо обычных документов могут быть, например, устройства и псевдоустройства, или бинарные файлы для запуска процессов.

`echo "Hello, Linux" > /dev/pts/0` - вывод фразы в псеводтерминал (pty) "0".

Все файлы (чем бы они не являлись) имеют стандартизированный и унифицированный интерфейс: открыть, читать, писать, закрыть и т.д. В Linux такой интерфейс обеспечивает _файловая система_.


