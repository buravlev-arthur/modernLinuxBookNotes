# modernLinuxBookNotes

Important notes from "Learning modern Linux" (Hausenblas M. - 2022).

### Глава 1. Введение

`cat /proc/version` - версия Linux
`cat /proc/cpuinfo | grep "model name"` - информация о ядрах ЦП
`cat /proc/$$/status | head -n6` - первые шесть строк статуса текущего процесса (переменная $$ - текущий процесс)

### Глава 2. Ядро Linux

#### Процессор

`lscpu` - информация о процессоре
`uname -m` - архитектура процессора
`cat /proc/cpuinfo` - вся информация о всех CPU

##### Управление процессами в Linux

- Сессии (SID)
- Группы процессов (PGID)
- Процесс (адресное пространство, потоки, сокеты и т.п. (PID))
- Потоки (TID) / Мультипотоки (TGID) - в Linux представляют из себя процессы, которые раздают процессам ресурсы
- Задачи (структура task_struct определена в sched.h - базовая реализация Потоков и Процессов)

`ls /proc/self` - данные текущего процесса
`ps -j` - данные процессов
`ls /proc/<PID>/task/<TID>` - увидеть данные и ресурсы задачи процесса

#### Память RAM

Виртуальная память -> Процесс [таблица страниц памяти процесса] <- Физическая память (RAM)
TLB кэширует физические адреса страниц памяти процесса для ускорения работы процессора.
Стандартный размер страницы памяти - 4 KB. В сорвеменных Linux используются более крупные страницы памяти.

`grep MemTotal /proc/meminfo` - объяем физической памяти
`grep VmallocTotal /proc/meminfo` - объём виртуальной памяти
`grep Hugepagesize /proc/meminfo` - размер страницы памяти

#### Сеть

Linux-стек:

- Сокеты (абстракции соединений)
- TCP/UDP
- IP

`ip link` - сетевые интерфейсы
`ip route` - сетевые маршруты

#### Файловая система

Множество видов: ext4, ntfs, btrfs.
VFS - виртуальные файловые сестемы используется для одновременной работы со множеством типов и экземляров файловых систем.

#### Устройства

Драйверы устройств (физических и псевдо-устройств) хранятся в ядре статически или в виде модулей.

`ls /sys/devices` - список устройств

#### Системные вызовы

Несколько сотен. Вызываются напрямую, либо через "C standart library" (реализации: glibc, musl).
Системные вызовы - это программные прерывания, вызывающие исключения, которые передают управление обработчику исключения.
В syscall.h хранится таблица системных вызовов (переменная sys_call_table), хранящая последовательность системных вызовов и их обработчиков.
system_call() - функция мультиплексор, сохранающая контекст ап.обеспечения в стэк, делающая проверки и вызывающая в конце обработчик исключения из sys_call_table.

`strace ls` - список системных вызовов, вызываемых командой ls
`strace -c curl -s https://google.ru > /dev/null` - вывод затрат времени на системные вызовы (/dev/null - направить вывод вникуда)

Список системных вызовов: https://filippo.io/linux-syscall-table/

#### Расширения ядра

`uname -srm` - имя, релиз ядра и архитектура машины
`find /lib/modules/$(uname -r) -name "*.ko*" -type f` - поиск доступных модулей для текущего ядра
`lsmod` или `cat /proc/modules` - список загруженных модулей
`modprobe --show-depends video` - показать зависимости модуля video

##### eBPF (Berkeley Packet Filter)

Начиная с версии Linux-ядра 3.15 расширать его функциональность можно с помощью системного вызова bpf. eBPF реализован как виртуальная машина внутри ядра с набором RISC-инструкций.

### Глава 3. Оболочки и сценарии

`echo $TERM` - название используемого терминала
`infocmp` - конфигурация используемого терминала
`sh` - запуск оболочки (сегодня по-умолчанию bash (Bourne Again Shell), наследница оригинальной Bourne Shell)
`echo $0` - имя используемой оболочки (а вообще имя текущего процесса)

#### Потоки

Оболочка определяет для каждого процесса три файловых дескриптора (FDs):

- stdin (FD 0)
- stdout (FD 1)
- stderr (FD 2)

`cat file.txt 1> output.txt 2> err.txt` - вывести поток stdout из файла file.txt в файл output output.txt а stderr - в err.txt
`cat file.txt &> output.txt` - вывести оба потока stdout и stderr в output.txt
`cat file.txt > /dev/null` - убрать поток stdout
`cat > output.txt` - записывать ввод в файл (Ctrl + D для выхода и сохранения)
`tr < result.txt [A-Z] [a-z]` - команда tr читает поток stdin из файла result.txt и заменяет все заглавные символы на строчные
`echo "Error" >&2` - вывод строки Error в поток stderr

Специальные символы:
`&` - выполняет команду в фоновом режиме
`/` - переводит запись команды на следующую строку
`|` - передаёт stdout (команды слева) в stdin (команды справа)

Команда убирает статус об ошибке, передают stdout curl'а в stdin wc и записана с переносом строки (/):

```bash
curl https://example.com 2> /dev/null | \
wc -l
```

#### Переменные

- Переменные окружения (`env`)
- Переменные оболочки (`set`)

`set MY_VAR=42` - создаём переменную оболочки
`set | grep 'MY_VAR'` - выводим переменную со значением
`export MY_GLOBAL_VAR=42` - создаём переменную окружения
`env | grep 'MY_GLOBAL_VAR'` - выводим переменную окружения
`unset $MY_VAR` - удаление переменной
`bash` - создаём новую сессию - дочерний процесс процесса текущей сессии
`exit` - выход из процесса сессии
`echo $?` - статус выхода (exit status). 0 - успешно, 1-255 - ошибка
`echo $PIPESTATUS` - тот же exit status, но для применения в конвеерах

#### Предустановленные команды оболочки

Расположены:
`/usr/bin` - пользовательские команды
`/usr/sbin` - административные команды

`which cat` или `type cat` - узнать, где расположен исполняемый код команды cat

#### Shell jobs

`watch -n 5 "ls" &` - watch выводит результат ls каждые 5 секунд, а & переводит работу в фоновый режим
`jobs -l` - список текущих работ
`fg` - перевести работу из фонового режима на экран

[Ctrl + C] - прекращение работы
[Ctrl + Z] - перевод работы в фоновый режим

`nohup ./job.sh` - работа не прикратит выполнение после закрытия терминала, а stdout направлен в ~/nohup.out
`disown -h 1000` - блокировка сигнала SIGNUP без удаления задачи из таблицы оболочки (-h), где 1000 - Job ID

#### Современные аналоги популярных команд

`exa` - просмотр каталога (Install: apt install exa)
`rg -t txt text` - найти и вывести файлы с расширением txt с текстом "text" (Install: $sudo apt-get install ripgrep)
`bat text.txt` - чтение файла с прокрутой (Install: sudo apt install bat; mkdir -p ~/.local/bin; ln -s /usr/bin/batcat ~/.local/bin/bat)
`jq '.[] | select(.favoriteFruit=="strawberry") | .friends[0].name' someData.json` - поиск в JSON имен первых друзей людей, кто любит клубнику (Install: sudo apt-get install jq)

#### Рутинные задачи

`alias d="exa -T -L 1"` - создание алиаса d для команды exa
`unalias d` - удаление алиаса

`echo "Second line" >> /tmp/file` - добавить строчку в конец файла
`sed 's/line/LINE/' /tmp/file` - замена всех подстрок line на LINE
`cat << 'EOF' > /tmp/file` - Записать введенный текст в file с помощью Here Document (https://tldp.org/LDP/abs/html/here-docs.html)
`diff -y file1 file2` - сравнение строк файлов в две колонки (-y)

##### Навигация с помощью горячих клавиш

`CTRL + A` - в начало строки
`CTRL + E` - в конце строки

`CTRL + K` - удалить всё справа
`CTRL + U` - удалить всё слева

`CTRL + W` - удалить слово слева

`CTRL + R` - поиск
`CTRL + G` - закрыть поиск

##### Многостраничные файлы

Просмотр многостраничных файлов возможен с помощью пэйджеров: `less`, `bat`; или с помощью вывода куска файла: `head`, `tail`.
`head -5 file` - вывести первые пять строк файла
`tail -f file` - просмотр конца файла с обновлением при увеличении строк в файле (-f)

##### Дата и время

`date -d @1000000000 '+%d.%m.%Y %H:%M:%S'` - вывод даты и времени с timestamp 1000000000

##### Fish Shell

`set -x MY_VAR VALUE` - определение глобальной переменной
`set -e MY_VAR` - удалить глобальную переменную
`env MY_VAR=10 npm run dev` - установка переменной окружения для команды
`abbr --add l ls -la` - добавление синонима l для команды ls с параметрами -la
`config_fish` - открыть в браузере настройки оболочки
`functions` - просмотр всех доступных функций
`function func_name` - добавление/редактирование функции, пример:

```bash
function f
    git pull origin main
end
```

`funced func_name` - просмотр тела функции

##### Мультиплексор терминала

- "screen". Оригинальный, устаревший.
- "tmux". Состоит из трех элементов: сессии -> окна -> панели.

`tmux new -s test` - создание новой сессии test
`tmux ls` - просмотр всех сессий
`tmux attach -t test` - запуск сессии test в терминале

Команды tmux:
**trigger/prefix**: Ctrl + b

**trigger + $** - переименовать сессию
**trigger + s** - просмотреть все сессии
**trigger + d** - завершение текущей сессии

**trigger + c** - создание нового окна
**trigger + ,** - переименование окна
**trigger + [N | P]** - перейти к следующей/предыдущей странице
**trigger + [0-9]** - перейти в окно с указанным номером
**trigger + w** - просмотр всех окон в сессии
**trigger + &** - закрытие текущего окна

**trigger + "** - разделить окно горизонтально
**trigger + %** - разделить окно вертикально
**trigger + [up | down | left | right]** - перемещение между панелями
**trigger + z** - переключиться на текущую панель/на все панели
**trigger + x** - закрыть панель

##### Автоматизация (скрипты)

- Массивы
  `arr=('First', 'Second', 'Third')` - массив из трех элементов
  `echo ${arr[1]}` - вывод первого элемента массива
  `echo ${arr[@]}` - вывод всех элементов массива
  `echo ${#arr[@]}` - вывести количество элементов массива

- Цикл FOR

```bash
for afile in ~/* ; do
    echo $afile
done
```

```bash
for i in {1..10}; do
    echo $i
done
```

```bash
while true; do
    echo "Hello"
done
```

- Функции

```bash
sayhi() {
    echo "Hi $1 hope you are well!"
}

sayhi "John"
```

Требования к скрипту:

- .sh-расширение файла (хотя, не обязательно)
- в первой строке: #! (shebang, указывающий на интерпритатор). Например: #!/usr/bin/env bash
- файл должен быть исполняемый: `chmod +x` (могут исполнять _все_) или `chomd 750` (могут исполнять _пользователь_ и его _группа_)

**Шаблон скрипта**:

```bash
#!/usr/bin/env bash
# завершать, если найдена ошибка
set -o errexit
# выдавать ошибку, если переменные не определены
set -o nounset
# если часть конвейера с ошибкой, прерывать весь конвейер
set -o pipefail

firstargument="${1:-somedefaultvalue}"

echo "$firstargument"
```

**Хорошие практики**:

1. Завершать скрипт шумно и быстро (errexit, pipefail);
2. Чувствительная информация (пароль) должна передаваться в скрипт через пользователский ввод или через API;
   Команда `ps` выводит параметры программы и т.п;
3. Устанавливать значения по-умолчанию для параметров запуска и ввода (read), где это возможно. И валидировать полученные от пользователя данные;
4. Проверять наличие всех пакетов и при необходимости устанавливать их через скрипт (wget);
5. Обрабатывать ошибки и сообщать пользователю, что произшло и что делать;
6. Комментарировать (`# doc here`) и не писать строки длинее 80 символов;
7. Версионировать скрипты через Git;
8. Проводить линтинг и тестирование скриптов.

**Тестирование, линтинг и форматирование**:

- Линтинг:
  `sudo apt install -y shellcheck` - установка _shellcheck_
  `shellcheck script.sh` - линтинг script.sh скрипта

- Форматирование:
  `sudo apt install -y shfmt` - установка форматера _shfmt_
  `shfmt -l -w script.sh` - форматтинг скрипта script.sh

- Тестирование:
  `sudo apt install bats` - установка тестовой среды bats

Тестовые утверждения в tests.bats:

```
@test "invoking param string" {
        run ./firstScript.sh testString
        [ "$output" = "testString" ]
}

@test "invoking exit status" {
        run ./firstScript.sh testString
        [ "$status" -eq 0 ]
}
```

`bats tests.bats` - запуск тестов

- Шпаргалка по bash: https://devhints.io/bash
- Фреймворки: bashing, rr, rerun

### Глава 4. Контроль доступа

**Пользователь**: владеет ресурсом и запускает процесс
**Процесс**: использует ресурс

**Ресурс** - исполняемый файл, загруженный ядром в память и запущенный.

Два типа контроля доступа:

- Дискреционный доступ (DAC). Ограничение доступа основано на идентификаторе пользователя, который может давать права на свои ресурсы другим пользователям.
- Мандатный доступ. Представляет иерархию видов доступа, где пользователь имеет доступ только к ресурсам своего уровня или ниже. Только администратор
  может контролировать уровни доступа. Пользователь не может настраивать права доступа к ресурсам, которыми владеет. Реализации: SELinux, AppArmor.

Два типа пользователей:

- **Системные пользователи**. Чаще всего программы (_deamons_), которые могут быть частью ОС (_sshd_) или часть пользовательского ПО (_mysql_);
- **Обычные пользователи**. Например, живой человек, использующий Linux через shell.

_User ID (UID)_ 32-битный числовое значение, обрабатываемое Linux. Пользователь принадлежит к одной или нескольким группам, которые идентифицируются с помощью
_Group ID (GID)_. Пользователь с UID 0 - это root-пользователь.

Разные дистрибутивы по-своему управляют порядком UID. В дистрибутивах основанных на _systemd_ порядок следующий:

- 0 - root-пользователь;
- 1-999 - системные пользователи;
- 65534 - nobody-пользователь (используется например, для сопоставления удалённых пользователей с существующими);
- 1000 - 4 294 967 294 (кроме 65534) - обычные пользователи

`id -u` - вывод UID текующего пользователя

#### Локальное управление пользователями

`/etc/passwd` - база пользователей
`/etc/group` - база групп
`/etc/shadow` - пароли пользователей
`/etc/gshadow` - пароли групп

**Поля пользователя**:

`user:x:1000:2100:john adams:/user:/bin/bash` - запись в `/etc/passwd`, где справа-налево:

- `/bin/bash` - shell-оболочка для входа в систему (`/sbin/nologin` - если это системный пользователь);
- `/user` - домашняя директория пользователя;
- `john adams` - GECOS-поле; чаще всего полное имя пользователя;
- `2100` - основная группа (GID) пользователя;
- `1000` - идентификатор пользователя (UID);
- `x` - пароль зашифрован и хранится в `/etc/shadow`;
- `user` - имя пользователя в системе (не более 32 символов).

Добавить пользователя:

```bash
sudo adduser username
```

Команда создаёт запись в `/etc/passwd`, создаёт группу для пользователя в `/etc/group`, создаёт домашнюю директорию: `/home/username` и копирует в неё базовые конфигурации из
`/etc/skel`. Все настроки команды находятся в: `/etc/adduser.conf`.

Добавить системного пользователя (без домашней директории и shell'а для входа):

```bash
sudo adduser --system system_user_name
```

**Поля группы**:

`groupname:x:1000:user1,user2,user3` - запись в `etc/group`, где справа-налево:

- `user1,user2,user3` - пользователи, входящие в группу;
- `1000` - идентификатор группы (GID);
- `x` - пароль зашифрован и хранится в `/etc/gshadow`;
- `groupname` - имя группы; часто совпадает с именем обычного или системного (deamon'а) пользователя.

#### Централизованное управление пользователями

Подходы к централизованному управлению пользователями:

- **Основанный на директориях** - _LDAP (Lightweight Directory Access Protocol)_ - протокол управления доступом к директориям, распространяемым через IP-протокол. Опенсорс-сервер: [Keycloak](https://www.keycloak.org/);
- **Через сеть** - пользователи могут быть подключены через протокол _Keberos_;
- **Системы управления конфигурацией** - системы _Ansible_, _Chef_, _Puppet_ используются для последовательного создания пользователей на разных машинах.

Выбор подхода часто заранее продиктован определенным окружением.

#### Права доступа к файлам

Три типа пространств прав доступа:

- Пользователь (владелец файла);
- Группа (Один или более членов);
- Другие.

У каждого пространства три типа доступа:

- Чтение (`r`). Позволяет просматривать файл и имена файлов внутри директории;
- Запись (`w`). Позволяет редактировать файл и создавать/переименовывать/удалять файлы в директории;
- Исполнение (`x`). Позволяет исполнять файл (если также есть право на чтение) и даёт доступ к информации о файлах в директории (можно пользоваться командами `cd` и `ls`).

Также есть ещё несколько типов доступа:

- `s` - для исполняемых файлов. Позволяет пользователю, исполняющему файл наследовать права владельца/группы файла;
- `t` - для директорий. Запрещает удалять файлы внутри директорий не root-пользователю, если только он не является владельцем директории.

Строка из вывода команды `ls`:

`-rwxr-x--- 1 user group  593 Sep  1 15:56 gh-user-info.sh`, где слева-направо:

- `gh-user-info.sh` - имя файла;
- `Sep 1 15:56` - временная метка последнего обновления;
- `593` - размер файла в байтах;
- `group` - группа, которой пренадлежит файл;
- `user` - владелец файла;
- `1` - количество жёстких ссылок;
- `-rwxr-x---` - тип и права файла, где справа-налево:
  - `-` - тип файла со значениями:
    - `-` - обычный файл;
    - `d` - директория;
    - `l` - символическая ссылка;
    - `s` - сокет;
    - `b` - блочный файл;
    - `c` - символьный файл;
    - `?` - неизвестный тип файла.
  - `rwx` - права владельца файла;
  - `r-x` - права группы владельца;
  - `---` - права остальных пользователей.

Права для типа пространств (владелец, группа, другие) можно представить в виде числа, если перевести запись вида `rwx` в двоичный вид. Например для `r-x` это 5, а для `rwx` - 7.
Права `664` (чтение и запись для владельца и его группы и только чтение для остальных) присваивается в системе по умолчанию всем новым файлам.

`umask` - маска прав на новые файлы/директори по умолчанию. В ответе `0002` первая цифра опускается. Для файлов: `666 - 002 = 664`, для директорий: `777 - 002 = 775`.
`umask -S` - посмотреть права по-умолчанию в формате `u=rwx, g=rwx, o=rwx`.
`umask 224` - установить новую маску с правами для файлов: `442`, для директорий: `553`.

Изменение прав на файл:

`chmod +x file.txt` - добавить для всех право на исполнение
`chmod 644 file.txt` - установить права `rw-r--r--` для файла

Изменение владельца и группы:

`sudo chown username file.txt` - смена владельца фала на username
`sudo chgrp groupname file.txt` - смена группы на groupname

#### Права доступа к процессам

К процессу имеют доступ:

- **Real UID**. Пользователь, запустивший этот процесс (владелец). Получить UID можно с помощью системного вызова: `getuid(2)` или с помощью команды:

`stat -c "%u %g" /proc/$$/` - информация о владельце и группе-владельце текущего процесса;

- **Effective UID**. Используется для определения прав процесса на доступ к общим ресурсам. Получить можно с помощью: `geteuid(2)`;
- **Saved set-user-ID**. Используется для получения suid (root). Для получения необходимых прав процесс может переключать его _Effective UID_ между _Real UID_ и _Saved set-user-ID_. Например, для получения доступа к порту процессу должны быть предоставлены root-права. Может быть получен с помощью: `getresuid(2)`;
- **Filesystem UID**. Специфичен для Linux. Используется для предоставления доступа процессу к файлам от имени пользователя, который тем временем изолирован от действий над этим процессом. С версии ядря 2.0 может не использоваться, но поддержка сохранена путём синхронизации _Filesystem UID_ с _Effective UID_. Получить: `getfsuid(2)`.

_POSIX threads_ требует данные для входа, доступные всем потокам. Но ядро Linux поддерживает отдельные данные для входа для пользователей и групп в каждом потоке.

Ядро так же использует UID's процесса для других целей (помимо доступа к файлам): установка прав доступа для отправки сигналов (`kill -9`), обработки прав доступа для планирования и установки приоритетов, проверки ограничений ресурсов и т.д.


##### Capabitilites

Ядро Linux различает только два состояния:

- **Привелигированный процесс**: запущен от имени суперпользователя (_Effective UID_: 0), игнорирующий все проверки на права доступа ядра;
- **Непривелигированный процесс**: (_Effective UID_ отличен от 0), для которого ядро выполняет все проверки прав доступа.

C появлением системного вызова `capabilities(7)` привелигированный процесс (root) разбит на несколько независимых единиц, каждая из которых связана с соответствующим уровнем потоков.
Теперь можно исполняемым файлам (бинарным или shell-скриптам) постепенно увеличивать уровень _Capabilities_, чтобы они могли выполнить поставленную задачу.

`capsh --print` - просмотр всех capabilities
`grep Cap /proc/$$/status` - capabilities текущего процесса

Можно управлять capabilities с помощью команд `getcap` и `setcap`. 

##### Seccomp-профили

Secure computing mode (seccomp) позволяет с помощью системного вызова `seccomp(2)` ограничить системные вызовы, доступные процессу. _Docker_ и _Kubernets_ используют _Seccomp_ для формирования песочниц (изолированного окружения).


##### Access control list

_ACL_ позволяет наделять правами пользователей и группы, которых нет в списке групп пользователя.

`grep -i posix_acl=y /boot/config*` - проверка поддержки _ACL_ системой (если строчки `posix_acl=y` есть - _ACL_ поддерживается)

**Хорошие практики**:

1. **Меньше прав доступа**. Файлам стоит давать только те права доступа, которые необходимы для работы с ними. В `chmod` лучше использовать цифровые коды, нежели общие символы вроде: `+x`, которые дают доступ всем типам пользователей. Не входить в систему под root-пользователем, а использовать `sudo` по возможности. При написании приложений нужно использовать _SELinux_ с политикой, дающей приложению доступ только к выбранным файлам, директориям и другим видам ресурсов системы;
2. **Избегать setuid**. Вместо этого использовать `capabilities`;
3. **Аудирование**. Рекомендуется вести журнал действий, который нельзя подделеать, чтобы можно было контролировать кто когда и что делал в системе.

### Глава 5. Файловая система

Главная абстрация в Linux - файл. Почти всё в Linux - файл. Файлом помимо обычных документов могут быть, например, устройства и псевдоустройства, или бинарные файлы для запуска процессов.

`echo "Hello, Linux" > /dev/pts/0` - вывод фразы в псеводтерминал (pty) "0".

Все файлы (чем бы они не являлись) имеют стандартизированный и унифицированный интерфейс: открыть, читать, писать, закрыть и т.д. В Linux такой интерфейс обеспечивает _файловая система_.

- Большистно файловых систем иерархические (одно дерево с корнем в `/`);
- Дерево состоит из файлов и директорий. Директории - узлы дерева (nodes), файлы и директории внутри - листья (leaves).
- Основные команды: `ls`, `cd`, `pwd`;
- Обычно файловая система реализована в ядре ОС. Но есть реализации на пользовательском слое: `FUSE (Filesystem in user space)`, (libfuse)[https://github.com/libfuse/].

#### Термины

- **Диск (Drive)**: `/dev/sda` (SCSI-устройства), `/dev/sdb` (SATA-устройства), `/dev/hda` (IDE-устройства);
- **Раздел (Partition)**: логическое разделение диска на разделы. В файловой системе будут представлены как: `/dev/sdb1`, `/dev/sdb2`;
- **Tom (Valume)**: более гибкий аналог раздела, также имеющий собственный экземпляр файловой системы;
- **Super block**: в начале памяти файловая система имеет специальный блок, хранящий мета-данные: тип файловой системы, блоки, состояние, количество индексных дескрипторов на блок;
- **Индексный дескриптор (Inode)**: число, однозначно идентифицирующее файл в файловой системе. Хранит мета-данные о файле (размер, расположение, владелец, дата модификации и т.п.). Название и содержание файла хранит директория, которая является разновидностью обычного файла, которая преобразует индексные дескрипторы файлов в их имена.

`lsblk --exclude 7` - отобразить все блочные устройства с исключением псевдо-устройств (loop). 1 уровень дерева - устройства; 2 уровень - разделы; 3 уровень - Тома.
`findmnt -D -t nosquashfs` - вывод всех файловых систем в формате команды `df` и исключая "squashfs" файловую систему (для CDROM'ом и Snapshot'ов)
`stat filename` - информация о файле в контексте файловой системы
`ls -i` - содержание директории с указателями


#### Ссылки

Существует два типа:

- **Жёсткие ссылки (hard links)**. Указывают на тот же inode, что и оргиниальный файл. Не применимы для директории и не могут использоваться в разных файловых системах;
- **Символьные ссылки (symlinks)** - мягкие ссылки, которые представляют отдельные файлы, содержащие путь до оригинального файла. Не связаны с оригинальным файлом (символьная ссылка остаётся при удалении или перемещении оригинального файла).

`ln file hardlinkOfFile` - создание жёсткой ссылки на файл
`ln -s file symlinkOfFile` - создание мягкой ссылки на файл


#### Virtual File System (VFS)

Для представления множества ресурсов (локальных и сетевых, хранимых в ОЗУ) в виде файлов система использует абстрацию - _VFS_.

_VFS_ предоставляет прослойку в ядре, который реализует взаимодействие между клиентом (syscalls) и различными реализациями базовых команд (чтение, запись, поиск ресурсов) разных файловых систем.

Файл с применением данной абстрации не имеет какой-либо структуры, а представляет собой поток байтов. Только клиент определяет, что каждый байт значит.

Файловые системы, к которым предоставляет доступ _VFS_:

1. **Локальные ФС** (ext3, FAT), использующие драйвера для доступа к локальным блочным устройствам (HDD, SSD);
2. **Файловые системы в памяти** (tmpfs), работающие только в RAM;
3. **Псевдо-файловые системы** (procfs), использующиеся для взаимодействия с ядром и устройствами и работающие также в RAM;
4. **Сетевые файловые системы** (NFS, Samba, Netware), использующие драйвера и сетевые операции для доступа к устройствам хранения данных по сети.

Существует более ста системных вызовов для работы с файловыми системами. Есть специфичные для отдельных ФС и универсальные в _VFS_.

Ядро формирует VFS-релевантные структуры, описанные в `/include/linux/fs.h`:

- **inode**, хранящая размер, владельца, статистику, права доступа и указатели на блоки с данными на устройстве;
- **file**, представляющая открытый файл с путём, позицией и _inode_;
- **dentry (directory entry)**, хранящая родители и потомков директории;
- **super_block**, представляющая информацию о файловой системе и точке монтирования;
- **vfsmount**, **file_system_type** и другие.

#### Управление логическими томами

Разделами (partition) сложно управлять, особенно когда нужно изменять их размер. Для этих целей используются логические тома. 

_LVM (Logical Valume Manager)_ использует прослойку между физическими блочными устройствами и файловой системой (что позволяет легко и динамично управлять их размером) и состоит из трех концептуальных блоков:

- **Physical Valumes (PV)** (физические тома), представляющие разделы диска или целый диск;
- **Valume Groups (VG)** (группы томов), которые объединяют разделы дисков, полные диски и другие блочные устройства в группу.
- **Logical Valumes (LV)** (логические тома), которые можно создавать из групп томов (VG), и которые напоминают обычные разделы: нужно создать на них файловую систему, чтобы начать использование.

`sudo lvscan` - вывод всех логических томов в системе
`sudo vgs` - вывод всех групп томов в системе
`sudo pvdisplay` - вывод физичесских томов и ассоциированных с ними групп томов

#### Операции с файловой системой

##### Создание логического тома:

1. `sudo fdisk -l` - идентифицировать файл нужного блочного устройства (диска);
2. `sudo pvcreate /dev/sdb` - создать физический том на устройстве `sdb`;
3. `sudo vgcreate valume-group-name /dev/sdb` - создать группу томов на том же устройстве;
4. `sudo lvcreate -L 2.00G -n logical-valume-name valume-group-name` - создать логический том в группе томов на диске `sdb` с размером: 2 гигабайта.

##### Создание файловой системы:

1. `sudo mkfs -t ext4 /dev/mapper/<vg-name>-<lv-name>` - cоздание файловой системы (в других ОС: форматирование) логическом томе;
2. `sudo mount -a /dev/mapper/<vg-name>-<lv-name> ./dir-for-mount` - монтирование раздела/тома с созданной ФС в дерево текущей ФС. Флаг `-a` позволяет `mount` перебрать все доступные ФС раздела/тома для монтирования.

Убедиться, что ФС смонтирована в каталог можно с помощью команд: `lsblk`, `df`, `mount`.

Для перманентного монтирования раздела/тома необходимо добавить строку в файл `/etc/fstab` следующего вида:

`/dev/<block-device> /mount-folder ext4 defaults 0 2`, где 0 - не нужно создавать резевную копию раздела, 2 - низкий приоритет проверки раздела на целостность.


#### Структура файловой системы

Обший стандарт - _FHS (Filesystem Hierarchy Standart)_, описанный [здесь](https://refspecs.linuxfoundation.org/FHS_3.0/fhs/index.html).На практике структура директорий зависит от дистрибутива и описана в `man hier`.

Основные каталоги верхнего уровня:

- `/bin`, `/sbin` - системные программы (сссылки в: `/usr/bin`, `/usr/sbin`);
- `/boot` - образы ядра Linux и связанные с ним компоненты;
- `/dev` - устройства и псевдоустройства;
- `/etc` - файлы конфигурации программ и системы;
- `/home` - директории пользователей системы;
- `/lib` - системные библиотеки;
- `/mnt`, `/media` - директории для монтирования внешних блочный устройств;
- `/opt` - сильно зависит от дистрибутива; может хранить файлы менеджера пакетов;
- `/sys`, `/proc` - псевдо-файловые системы (интерфейсы ядра к устройствам, процессам и т.п.);
- `/tmp` - временные файлы;
- `/usr` - пользовательские программы (только чтение);
- `/var` - логи, кэши, бэкапы и т.п. пользовательских программ.

#### Псевдо-файловые системы

Псевдо-файловые системы лишь представлены в виде обычных файловых систем (где можно использовать команды: `cd`, `ls` и т.п.). На самом деле они предоставляют интерфейс к данным ядра:

- информация о процессах;
- взаимодействие с устройствами вроде клавиатуры;
- инструменты (такие как специальные устройства, которые можно использовать как источники данных и приёмнки);

##### procfs

Унаследованная из UNIX, `/proc` файловая система была реализована для возможности использования таких команд, как: `ps`, `free`. Отсюда можно получить информацию о процессах: `/proc/PID/`. Внутри директорий: данные о сети (`net`), памяти (`mem`), потоках (`task`), атрибутах безопасноти (`attr`), статусе процесса (`stat`) и т.д.

`cat /proc/$$/status` - вывод данных о статусе текущего (`$$`) процесса
`cat /proc/$$/net/arp` - вывод таблицы с данными протокола _ARP_ (разрешение ip- и mac-адресов) для текущего процесса

_procfs_ полезен для низкоуровневой отладки и системной разработки, но для понимания назначения файлов/директорий в данной псевдо-файловой системе требуется исходный код ядра.

##### sysfs

_sysfs_ (`/sys`) - современный структурированный аналог _procfs_ для Linux, со стандартизированной файловой структурой:

`block/` - содержит ссылки к обнаруженным блочным устройствам
`bus/` - содержит по одной директории для каждого поддерживаемого ядром типа шины
`class/` - классы устройств (`block`, `mem` и т.п.);
`dev/` - подкаталоги: `block` и `char` с ссылками (в `/devices`) на блочные и символьные устройства, отсортированные по Marjor-ID:Minor-ID;
`devices/` - представление дерева устройств;
`firmware/` - позволяет управлять атрибутами прошивки;
`fs/` - директории с используемыми файловыми системами, внутри которых устройства, использующие их;
`module/` - директории с модулями, загруженными в ядро.

Некоторые данные в `sysfs` дублируются из `procfs`, но некоторые данные (например, память) присутствуют только в `sysfs`.

`ls la /sys/block/sda/ | head -10` - вывод первых 10 файлов-данных устройства. Например, в `sda/dev` содержится Major-ID:Minor-ID устройства.

##### devfs

_devfs_ (`/dev`) - псевдо-файловая система для представления устройств в системе. В _devfs_ представлены как физические устройства (диски, клавиатура и т.п.), так и специфические вроде генератора случайных чисел до хранилищ данных (data sinks).

Виды устройств:

- Блочные (например, драйверы дисков);
- Символьные (терминалы, клавиатуры, мыши и т.п.);
- Специальные устройства, генерирующие или манипулирующие данными (`/dev/random`, `/dev/null` и т.п.).

`tr -dc A-Z-a-z0-9 < /dev/urandom | head -c 42` - генерация случайных символов и цифр длиной в 42 байта

`echo "something" > dev/tty1` - добавление строки в псевдо-файл терминала (приведет к обычному выводу строки в текущий терминал)

#### Дисковые файловые системы

Используемые в Linux:

- _ext2_ (1993), _ext3_ (2001), _ext4_ (2008);
- _btrfs_ (2009);
- _XFS_ (2001);
- _ZFS_ (2006);
- _NTFS_ (1997);
- _vfat_ (1995).

##### ext4

_ext4_ наследует обратную совместимость с _ext3_, в которой реализовано журналирование изменений в файловой системе, что обеспечивает быстрое восстановление в случае, например, отключения питания.

##### XFS

Разработана в ранние 90-ые для рабочих станций Silicon Graphics. Поддерживет огромные размеры файлов (до 8 эксабайт) и очень быстрый ввод-вывод. Используется в дистрибутивах Red Hat.

##### ZFS

Разработана в Sun Microsystems в 2001 году. Объединяет файловую систему и менеджер томов.

##### FAT

Семейство файловых систем (чаще всего применяется vfat), использующееся для совместимости с Windows и внешними (измлекаемыми) медиа-данными. Поддержка томов ограничена.

#### Файловые системы ОЗУ

- _debugfs_ - используется для отладки, чаще всего смонтирована в `/sys/kernel/debug`;
- _loopfs_ - частый кейс, это создание отдельного экземпляра _loopfs_ при монтировании loop-устройств, что позволяет работать с ними изолированно;
- _pipefs_ - обеспечивает работу конвееров; 
- _sockfs_ - представляет сетевые сокеты в виде файлов, находясь между системными вызовами (syscalls) и сокетами;
- _swapfs_ - реализует работы системы с пространством подкачки (swap);
- _tmpfs_ - хранит данные в кэшах ядра, энергозависима.

#### Операционные системы копирования при записи (CoW)

_CoW_ ускоряет ввод/вывод данных при меньшем использовании памяти. Общий принцип работы:

1. При копировании File_1 с блоками A, B и C в File_2 копируются не блоки, а только мета-данные, указывающие на эти блоки;
2. При изменении блока C (например), он единственный копируется в памяти, но при обращении к блока A и B в File_2, используются всё ещё блоки A и B из File_1.

_Объединенное монтирование_ - это возможность смотнировать в один каталог контент сразу из нескольких других. Темины "Верхня ФС" и "Нижняя ФС" указывают порядок слоёв при монтировании.

Реализации _Untion Mounts_:

- `Unionfs` - позволяет прозрачно накладывать файлы и директории, управляя приоритетами при монтировании. Была популярна в контекте использования CD/DVD;
- `OverlayFS` - Реализация для Linux, представленная в 2009 и реализованная в ядре в 2014 году. Когда файл открыт, его обработка происходит в основной ФС (лежащей выше или ниже);
- `AUFS (AnutherUnionFS)` - не включена ещё в ядро Linux; Использовать в _Docker_, который сегодня по умолчанию работает с _OverlayFS_ через драйвер _overlay2_.
- `btrfs (b-tree fs)` - изначально разработанная в Oracle, сегодня поддерживается рядом ведущих корпораций. Имеет ряд особенностей: снапшоты (для программного RAID), автоматическое обноружение скрытых повреждений данных.



